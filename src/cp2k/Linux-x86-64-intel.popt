# by default some intel compilers put temporaries on the stack
# this might lead to segmentation faults if the stack limit is set to low
# stack limits can be increased by sysadmins or e.g with ulimit -s 256000
# Tested on Strasbourg University HPC Mesocenter - Intel Composer ver.12, 13, 14 
# Note: -O2 produces an executable which is slightly faster than -O3
# and the compilation time was also much shorter.
#### Version OpenMPI (without OMP !)
CC       = mpicc
CPP      = /lib/cpp
FC       = mpif90 -FR
FC_fixed = mpif90 -FI
LD       = mpif90
AR       = /usr/bin/ar -r
#Better with mkl (intel lapack/blas) only
#DFLAGS   = -D__INTEL -D__FFTSG -D__parallel
#If you want to use BLACS and SCALAPACK use the flags below
LIBXC_INC  = LIBXCPATH/include
LIBXC_LIB  = LIBXCPATH/lib
DFLAGS = -D__INTEL -D__FFTSG -D__parallel -D__BLACS -D__SCALAPACK -D__FFTW3 -D__LIBINT -D__LIBXC2 -D__LIBINT_MAX_AM=6 -D__LIBDERIV_MAX_AM1=5 -D__MKL CUDADEFS
FFTW_INC = ROLLFFTW/include
CPPFLAGS = -C $(DFLAGS) -P -traditional -I$(FFTW_INC) -I$(LIBXC_INC)
FCFLAGS  = $(DFLAGS) -I$(FFTW_INC) -I$(LIBXC_INC) -O2 -xW -heap-arrays -funroll-loops -fpp -free
INTEL_LIB = MKL_ROOT/lib/intel64
#verify if the path to the mkl libraries is already defined and/or differs from this
LDFLAGS  = $(FCFLAGS) -LMKLROOT/lib/intel64
#If you want to use BLACS and SCALAPACK use the libraries below

LIBS     = $(INTEL_LIB)/libmkl_scalapack_lp64.a  -Wl,--start-group $(INTEL_LIB)/libmkl_intel_lp64.a $(INTEL_LIB)/libmkl_sequential.a $(INTEL_LIB)/libmkl_core.a $(INTEL_LIB)/libmkl_blacs_INTELMPITYPE_lp64.a -Wl,--end-group -lpthread  -LROLLFFTW/lib -lfftw3 -LLIBINTPATH -L$(LIBXC_LIB) -lxc -lxcf90 -lderiv -lint -lr12 -lstdc++ -ldl CUDALIBS -lm

NVCC = NVCCPATH
NVFLAGS = -ccbin `which icpc` $(DFLAGS) -O2 -gencode arch=compute_30,code=sm_30 -gencode arch=compute_37,code=sm_37 -gencode arch=compute_50,code=sm_50 -gencode arch=compute_60,code=sm_60 -gencode arch=compute_61,code=sm_61 -gencode arch=compute_70,code=sm_70
LDFLAGS_C = $(FCFLAGS) -static-intel -nofor_main

# Required due to memory leak that occurs if high optimisations are used
mp2_optimize_ri_basis.o: mp2_optimize_ri_basis.F
	$(FC) -c $(subst O2,O0,$(FCFLAGS)) $<

